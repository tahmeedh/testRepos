// import { SMClient, CompanyManager, UserManager } from '@jsat-api/sm-api';

import { v4 as uuidv4 } from 'uuid';
import { SMClient, CompanyManager, UserManager } from '../sm-api';
import { Company, User, DirectoryTypes, PlatformTypes } from '../sm-api'

import {smThrift} from '../playwright.config';
import { companyPrefixName } from "../playwright.config";

import { StringUtils } from './string-utils';

export class companyCreateManager {
    readonly stringUtils : StringUtils;

    readonly smClient : SMClient;
    readonly companyManager : CompanyManager;
    readonly UserManager : UserManager;
    readonly companyPrefix : string;
    
    readonly domain : string;
    readonly companyLegalName : string;
    readonly APPS : any;

    company1 : Company;
    cid : number;
    users : User[];
    companiesCreated : number;
    companies : Company[];    
    roles : any;
    

    constructor() {
        this.stringUtils = new StringUtils();
        this.smClient = new SMClient(smThrift.host, smThrift.port);
        this.companyManager  = new CompanyManager(this.smClient);
        this.UserManager = new UserManager(this.smClient);
        this.companyPrefix = companyPrefixName || 'default';

        this.domain = `${uuidv4()}.com`;
        this.companyLegalName = `jsat-e2e-${uuidv4()}`;
        this.company1 = null;
        this.cid = null;
        this.users = [];
        this.companiesCreated = 0;
        this.companies = [];
        this.roles = null;
        this.APPS = {
            DIRECTORY: 'Directory',
            SERVICE_MANAGER: 'ServiceManager',
        };

    }

    randomInt (min, max) {
        // The maximum is inclusive and the minimum is inclusive
        const randInt = Math.floor(Math.random() * (max - min + 1)) + min;
        return String(randInt);
    }

    randomPhone () {
        const prefix = this.randomInt(2, 9) + this.randomInt(0, 9) + this.randomInt(0, 9);
        const mid = this.randomInt(2, 9) + this.randomInt(0, 9) + this.randomInt(0, 9);
        const end = this.randomInt(0, 9) + this.randomInt(0, 9) +
            this.randomInt(0, 9) + this.randomInt(0, 9);

        return prefix + mid + end;
    }

        /**
     * Initialises company and user data
     * this.companies = {Array.<Company>} Each company generated by this function are stored into the companies array
     * @param {number} numberOfUsers number of users to create
     * @param {Array.<String>} directoryRoles Directory roles to be given to users
     * @param {Array.<String>} smRoles Service manager roles to be given to users
     * @param {boolean} disableAllRoster false if all users should add each other to their roster.
     *                                   true if users should not add each other to their roster.
     */
    async init (numberOfUsers, directoryRoles = [], { disableAllRoster = false } = {}) {
        // Create the company
        this[`company${this.companiesCreated + 1}`] = await this.createCompany();
        this.companies.push(this[`company${this.companiesCreated}`]);
        const companyName = `company${this.companiesCreated}`;
        this.cid = this[companyName].smId;

        // Verify the domain has been created
        await this.validateDomain();

        // Create users for the company;
        this.users = [];
        for (let i = 0; i < numberOfUsers; i++) {
            this.users.push(await this.createUser(`Test${this.stringUtils.generateString(3, 6)}`, `User${(i + 1).toString()}`));
        }

        // Services must be enabled after users have been created
        await this.companyManager.enableAllServices(this[companyName]);
        this.roles = await this.getRoles();

        // Add all roles for all users
        for (let i = 0; i < this.users.length; i++) {
            await this.addAllRolesToUser(this.users[i]);
        }

        // Add Message Admin role to first user
        const smRoles = await this.getRoles(this.APPS.SERVICE_MANAGER);
        await this.addRoleToUser(this.users[0], smRoles['Message Administrator'], this.APPS.SERVICE_MANAGER);

        // Enable GR Message
        await this.companyManager.enableGrMessage(this.company1);

        // Update company directory settings
        const profilePolicyAttributes = new DirectoryTypes.UserProfileAttributeSettingStruct(
            { visibility: DirectoryTypes.AttributeVisibility.PUBLIC,
                editability: DirectoryTypes.AttributeEditability.TIGHT },
        );

        /**
         * Settings:
         *  Publish Directory (so users can find each other)
         *  Set all fields in user vcard to the following:
         *      Visibility:   Public
         *      Editable:  Directory
        */
        const settings = new DirectoryTypes.DirectorySettingsStruct(
            { companyId: this.cid,
                publishUsers: true,
                reportsToSettings: profilePolicyAttributes,
                workPhoneSettings: profilePolicyAttributes,
                homePhoneSettings: profilePolicyAttributes,
                mobilePhoneSettings: profilePolicyAttributes,
                jobTitleSettings: profilePolicyAttributes,
                firstNameSettings: profilePolicyAttributes,
                lastNameSettings: profilePolicyAttributes,
            },
        );
        await this.companyManager.updateDirectorySettings(settings);

        // Add users to each others roster
        if (numberOfUsers > 1) {
            const permutation = this.getPermutations(this.users, 2);
            for (let i = 0; i < permutation.length; i++) {
                const [userOne, userTwo] = permutation[i];
                // !!! WARNING, PLEASE CREATE AS LITTLE USERS AS POSSIBLE!!!.
                // With 8 users, this will call (8!/(8-2)!) 56 times.
                await this.addUserToRoster(userOne, userTwo);
                await this.addUserToRoster(userTwo, userOne);
            }
        }

        // Update user profiles
        let index = 0;
        for await (const user of this.users) {
            const newUser = await this.populateUserProfile(user);
            this.users[index] = newUser;
            index++;
        }
    }



        /**
     * Creates a company in SM.
     * @returns {Company} an sm.api.company.Company
     */
    async createCompany () {
        this.companiesCreated += 1;
        const company = new Company(`${this.companyLegalName}${this.companiesCreated}`, [`${this.domain}${this.companiesCreated}`]);
        await this.companyManager.create(company);
        return company;
    }

    /**
     * Verifies company has a domain that matches the one created by test data
     */
    async validateDomain () {
        try {
            let domains = await this.companyManager.getDomains(this[`company${this.companiesCreated}`]);
            let iterations = 10;

            while (iterations > 0) {
                if (domains.length < 1 || domains[0].name !== `${this.domain}${this.companiesCreated}`) {
                    domains = await this.companyManager.getDomains(this[`company${this.companiesCreated}`]);
                    iterations--;
                } else {
                    return;
                }
            }
            throw Error(`Could not find domain ${this.domain}`);
        } catch (err) {
            console.log('An error occurred while attempting to validate company domain');
        }
    }

        /**
     * Create a random user
     * @param {string} lastName The user's last name.
     * @param {string} firstName The user's first name.
     * @param {string} password The user's password.
     */
    async createUser (lastName, firstName = 'Auto_Test', password = 'password') {
        // Create user using UserManager
        const username = uuidv4();
        const email = `${username}@${this.domain}${this.companiesCreated}`;
        const user = new User(firstName, `User_${lastName}`, password, null, null, email, email);

        const { grcpAlias } = await this.UserManager.create(this.cid, user);
        user.userId = grcpAlias;
        return user;
    }

    /**
     * Get available roles in SM RoleID for assignment.
     * @param {string} application The possible application here are: 'Directory', 'ServiceManager'
     */
    async getRoles (application = this.APPS.DIRECTORY) {
        const app = this.getApplicationId(application);
        const assignableRoles = await this.companyManager.getRoles(this[`company${this.companiesCreated}`], app);
        const roles = {};
        assignableRoles.forEach((role) => {
            roles[role.roleName] = role.roleId;
        });
        return roles;
    }

        // Utility: Get the application ID from PlatformTypes.ApplicationName
    getApplicationId (application) {
        let app;
        switch (application) {
            case 'Archive':
                app = PlatformTypes.ApplicationName.Archive;
                break;
            case 'Directory':
                app = PlatformTypes.ApplicationName.Directory;
                break;
            case 'ServiceManager':
                app = PlatformTypes.ApplicationName.ServiceManager;
                break;
            case 'AI':
                app = PlatformTypes.ApplicationName.AI;
                break;
            default:
                console.log(`Cannot find the application: ${application}`);
        }
        return app;
    }

    /**
     * Assign all roles to a user (excluding "Beta" by default).
     * @param {User} user
     * @param {boolean} beta
     */
    async addAllRolesToUser (user, giveBetaEntitlement = false) {
        const roleKeys = Object.keys(this.roles);

        for (let i = 0; i < roleKeys.length; i++) {
            if (roleKeys[i] !== 'BETA User' || giveBetaEntitlement) {
                console.log(`Attempting to add role: '${roleKeys[i]}' to user: '${user.firstName}'`);
                await this.addRoleToUser(user, this.roles[roleKeys[i]], this.APPS.DIRECTORY);
            }
        }
    }

    /**
     * Assign a role to a user.
     * @param {User} user The user object to add role to.
     * @param {number} roleId The role Id to be added.
     * @param {string} application This is for thrift API. e.g. this.APPS.*
     */
    async addRoleToUser (user, roleId, application) {
        const app = await this.getApplicationId(application);
        await this.UserManager.addRole(user.smId, this.cid, roleId, app);
    }

    // Utility: Get the list of the Permutations base on the size
    getPermutations (array, size) {
        const result = [];
        function p (t, i) {
            if (t.length === size) {
                result.push(t);
                return;
            }
            if (i + 1 > array.length) {
                return;
            }
            p(t.concat(array[i]), i + 1);
            p(t, i + 1);
        }
        p([], 0);
        return result;
    }


    async addUserToRoster (user, contact) {
        await this.UserManager.addUserToRoster(user, contact);
    }

    /**
     * Populate the User Profile, this includes: job title, phone numbers...etc
     * @param {User} user An instance of the user object to update the profile for.
     */
    async populateUserProfile (user) {
        const profile = {
            jobTitle: `job_${uuidv4()}`,
            workPhone: this.randomPhone(),
            mobilePhone: this.randomPhone(),
            homePhone: this.randomPhone(),
        };

        const newUser = await this.UserManager.updateProfile(user, profile);
        return newUser;
    }

    async cleanup () {
        await this.companyManager.cleanup();
    }
}