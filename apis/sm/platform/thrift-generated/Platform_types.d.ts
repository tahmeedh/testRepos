//
// Autogenerated by Thrift Compiler (0.16.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
import thrift = require('thrift');
import Thrift = thrift.Thrift;
import Q = thrift.Q;
import Int64 = require('node-int64');


/**
 * DEPRECATED
 */
declare enum UserAliasType {
  EMAIL = 1,
  SIP = 2,
  GRID = 3,
}

declare enum ServiceSku {
  Archive = 1,
  DirectorySync = 2,
  GrMessage = 3,
  Directory = 4,
  LingUI = 8,
  GroupTags = 9,
  SearchAnalytics = 10,
  AKC = 11,
  AI = 12,
  MFA = 13,
  LogAPI = 14,
  DemoData = 15,
  GRWebsite = 16,
  Bloomberg = 5,
  ThomsonReuters = 6,
  ICE = 7,
}

declare enum ReportPackCode {
  BasicReportPack1 = 2,
  ReconciliationReportPack1 = 1,
  OperationalReportPack1 = 3,
}

declare enum ApplicationName {
  ServiceManager = 1,
  Archive = 2,
  Directory = 3,
  LegacyImport = 4,
  PlatformAdministration = 5,
  AI = 6,
  GRWebsiteArchive = 7,
}

declare enum AuthenticationType {
  Password = 0,
  SAML = 1,
}

/**
 * Visibility of the profile attribute.
 * 
 * <dl>
 *   <dt>PUBLIC</dt><dd>Visible to all users.</dd>
 *   <dt>COMPANY</dt><dd>Only visible to users within the same company.</dd>
 * </dl>
 */
declare enum AttributeVisibility {
  PUBLIC = 1,
  COMPANY = 2,
}

/**
 * Editability of the profile attribute.
 * 
 * <dl>
 *   <dt>NONE</dt><dd>Attribute is not editable.</dd>
 *   <dt>TIGHT</dt><dd>Attribute is tightly coupled, i.e. updating the user account record will update the user profile attribute and vice-versa.</dd>
 *   <dt>LOOSE</dt><dd>Attribute is loosely coupled, i.e. the user account record and user profile attribute can be updated independently.</dd>
 * </dl>
 */
declare enum AttributeEditability {
  NONE = 1,
  TIGHT = 2,
  LOOSE = 3,
}

declare enum DomainType {
  Company = 1,
  DoingBusinessAs = 3,
}

declare enum RegionType {
  CANADA = 0,
  USA = 1,
}

/**
 * STRUCTS
 */
declare class MailboxRecoveryAddressStruct {
  public userAliasId: Int64;
  public address: string;
  public isPreferred: boolean;
  public isDeactivated: boolean;
  public useForLogin?: boolean;

    constructor(args?: { userAliasId: Int64; address: string; isPreferred: boolean; isDeactivated: boolean; useForLogin?: boolean; });
}

declare class CompanyQueryStruct {
  public companyId?: number;
  public legalName?: string;
  public name?: string;

    constructor(args?: { companyId?: number; legalName?: string; name?: string; });
}

declare class CompanyStruct {
  public companyId: number;
  public legalName: string;
  public accountNumber?: string;
  public name?: string;
  public dateCreated?: Int64;

    constructor(args?: { companyId: number; legalName: string; accountNumber?: string; name?: string; dateCreated?: Int64; });
}

declare class CompanyDomainStruct {
  public companyDomainId: Int64;
  public name: string;
  public companyId: number;
  public type?: DomainType;

    constructor(args?: { companyDomainId: Int64; name: string; companyId: number; type?: DomainType; });
}

declare class GroupStruct {
  public companyId: number;
  public groupId: number;
  public name: string;
  public parentGroups?: number[];
  public childGroups?: number[];
  public displayName?: string;

    constructor(args?: { companyId: number; groupId: number; name: string; parentGroups?: number[]; childGroups?: number[]; displayName?: string; });
}

declare class GroupQueryStruct {
  public companyId: number;
  public groupId?: number;
  public name?: string;

    constructor(args?: { companyId: number; groupId?: number; name?: string; });
}

declare class FindGroupsResultStruct {
  public groups?: GroupStruct[];

    constructor(args?: { groups?: GroupStruct[]; });
}

declare class FindUsersResultsStruct {
  public userIds?: Int64[];

    constructor(args?: { userIds?: Int64[]; });
}

/**
 * This struct can be used to add user aliases when creating a user. As well as for returning alias information.
 * 
 * <dl>
 *  <dt>userAlias</dt><dd>user alias string.  Required.</dd>
 *  <dt>aliasType</dt><dd>user alias type.  Optional. DEPRECATED. USE PLATFORMCODE INSTEAD.</dd>
 *  <dt>aliasId</dt><dd>user alias id.</dd>
 *  <dt>useForLogin</dt><dd>True if alias is used for login.</dd>
 *  <dt>deactivated</dt><dd>True if user is deactivated. Only used for returning alias information.</dd>
 *  <dt>platformCode</dt><dd>Communication platform code.</dd>
 *  <dt>userId</dt><dd>SM user id the alias belongs to.</dd>
 *  <dt>isVerified</dt><dd>True if alias is verified.</dd>
 *  <dt>useForContact</dt><dd>True if alias is used for contact</dd>
 * </dl>
 */
declare class UserAliasStruct {
  public userAlias: string;
  public deprecated_aliasType?: UserAliasType;
  public aliasId?: Int64;
  public useForLogin?: boolean;
  public deactivated?: boolean;
  public platformCode?: string;
  public userId?: Int64;
  public isVerified?: boolean;
  public deprecated_useForContact?: boolean;

    constructor(args?: { userAlias: string; deprecated_aliasType?: UserAliasType; aliasId?: Int64; useForLogin?: boolean; deactivated?: boolean; platformCode?: string; userId?: Int64; isVerified?: boolean; deprecated_useForContact?: boolean; });
}

/**
 * Structure used for paging requests in queries.
 * <dl>
 *  <dt>startIndex</dt><dd>The start index of the first element to retrieve (startIndex * pageSize).</dd>
 *  <dt>pageSize</dt><dd>The size of the page to retrieve. Optional.</dd>
 * </dl>
 */
declare class PagingStruct {
  public startIndex?: number;
  public pageSize?: number;

    constructor(args?: { startIndex?: number; pageSize?: number; });
}

/**
 * Querying structure for finding user aliases.
 * <dl>
 *  <dt>paging</dt><dd>Structure for specifying paging information for the query. Optional.</dd>
 * </dl>
 */
declare class UserAliasQueryStruct {
  public paging?: PagingStruct;
  public aliasValue?: string;
  public platformCode?: string;
  public isVerified?: boolean;
  public deprecated_useForContact?: boolean;
  public userId?: Int64;

    constructor(args?: { paging?: PagingStruct; aliasValue?: string; platformCode?: string; isVerified?: boolean; deprecated_useForContact?: boolean; userId?: Int64; });
}

/**
 * This struct can be used when retrieving a users information.
 * 
 * <dl>
 *  <dt>displayName</dt><dd>Display name of the user.</dd>
 *  <dt>contactableEmailAlias</dt><dd>Address of the user.</dd>
 *  <dt>companyId</dt><dd>Company ID.</dd>
 *  <dt>companyLegalName</dt><dd>Company Legal Name.</dd>
 *  <dt>customerUserId</dt><dd>String that contains unique in scope of the company identifier, such as employee Id.</dd>
 *  <dt>firstName</dt><dd>First name of the user.</dd>
 *  <dt>lastName</dt><dd>Last name of the user.</dd>
 *  <dt>middleInitial</dt><dd>Middle initial of the user.</dd>
 *  <dt>userAliases</dt><dd>User aliases for the user.</dd>
 *  <dt>contactSupportMessage</dt><dd>The contact support message that should be seen by the user. Will not be set if the standard form is used.</dd>
 *  <dt>companyName</dt><dd>Company friendly name.</dd>
 *  <dt>deactivated</dt><dd>True if user is deactivated.</dd>
 *  <dt>location</dt><dd>User's current location.</dd>
 * </dl>
 */
declare class UserInfoStruct {
  public displayName: string;
  public email?: string;
  public companyId: number;
  public companyLegalName: string;
  public customerUserId?: string;
  public firstName?: string;
  public lastName?: string;
  public middleInitial?: string;
  public userAliases?: UserAliasStruct[];
  public contactSupportMessage?: string;
  public companyName?: string;
  public deactivated?: boolean;
  public location?: string;
  public userId?: Int64;

    constructor(args?: { displayName: string; email?: string; companyId: number; companyLegalName: string; customerUserId?: string; firstName?: string; lastName?: string; middleInitial?: string; userAliases?: UserAliasStruct[]; contactSupportMessage?: string; companyName?: string; deactivated?: boolean; location?: string; userId?: Int64; });
}

/**
 * This struct can be used when retrieving basic user information.
 * 
 * <dl>
 *  <dt>displayName</dt><dd>Display name of the user.</dd>
 *  <dt>email</dt><dd>Email address of the user.</dd>
 *  <dt>companyId</dt><dd>Company ID.</dd>
 * </dl>
 */
declare class UserInfoBasicStruct {
  public displayName?: string;
  public email?: string;
  public companyId?: number;

    constructor(args?: { displayName?: string; email?: string; companyId?: number; });
}

/**
 * This struct can be used when retrieving a system users information.
 * 
 * <dl>
 *  <dt>displayName</dt><dd>Display name of the user.</dd>
 *  <dt>companyId</dt><dd>Company ID.</dd>
 *  <dt>companyLegalName</dt><dd>Company Legal Name.</dd>
 *  <dt>loginid</dt><dd>The single loginId for the system user.</dd>
 * </dl>
 */
declare class SystemUserInfoStruct {
  public displayName?: string;
  public companyId?: number;
  public companyLegalName?: string;

    constructor(args?: { displayName?: string; companyId?: number; companyLegalName?: string; });
}

/**
 * This struct can be used when creating a system user to set name properties.
 * 
 * <dl>
 *  <dt>name</dt><dd>System user's name.  Optional.</dd>
 *  <dt>description</dt><dd>System user's description.  Optional.</dd>
 *  <dt>login</dt><dd>System user's login.  Required.</dd>
 * </dl>
 */
declare class SystemUserNameStruct {
  public name?: string;
  public description?: string;
  public login?: string;

    constructor(args?: { name?: string; description?: string; login?: string; });
}

/**
 * This struct can be used when creating test users to set their name properties.
 * 
 * <dl>
 *  <dt>firstName</dt><dd>User's first name.  Optional.</dd>
 *  <dt>lastName</dt><dd>User's last name.  Optional.</dd>
 *  <dt>middleInitial</dt><dd>User's middle initial.  Optional.</dd>
 *  <dt>userAlias</dt><dd>User's Alias.  Required.</dd>
 * </dl>
 */
declare class UserNameStruct {
  public firstName?: string;
  public lastName?: string;
  public middleInitial?: string;
  public aliases?: UserAliasStruct[];
  public customerUserId?: string;
  public email?: string;

    constructor(args?: { firstName?: string; lastName?: string; middleInitial?: string; aliases?: UserAliasStruct[]; customerUserId?: string; email?: string; });
}

/**
 * <dl>
 *  <dt>userId</dt><dd>Service Manager's User Id.  Unique Id of the User entity.</dd>
 *  <dt>grcpAlias</dt><dd>GRCP alias, such as 88@globalrelay.local.  The grcp alias is unique for the user (for life).</dd>
 *  <dt>userName</dt><dd>User name details.</dd>
 * </dl>
 */
declare class UserStruct {
  public userId: Int64;
  public grcpAlias: string;
  public userName?: UserNameStruct;

    constructor(args?: { userId: Int64; grcpAlias: string; userName?: UserNameStruct; });
}

/**
 * This struct is used to create company users and to set their properties.
 * 
 * <dl>
 *  <dt>firstName</dt><dd>User's first name.  Required.</dd>
 *  <dt>lastName</dt><dd>User's last name.  Required.</dd>
 *  <dt>middleInitial</dt><dd>User's middle initial.  Optional.</dd>
 *  <dt>customerUserId</dt><dd>Customer's User ID of the user. Optional.</dd>
 *  <dt>email</dt><dd>Email address. Required. Must be unique</dd>
 * </dl>
 */
declare class CompanyUserCreateStruct {
  public firstName?: string;
  public lastName?: string;
  public middleInitial?: string;
  public customerUserId?: string;
  public email?: string;

    constructor(args?: { firstName?: string; lastName?: string; middleInitial?: string; customerUserId?: string; email?: string; });
}

/**
 * SAML Authentication information for a Company User login.
 * 
 * <dl>
 *  <dt>idpIdentifier</dt><dd>The identifier of the SAML identify provider's configuration. Required</dd>
 */
declare class SamlAuthStruct {
  public idpIdentifier?: string;

    constructor(args?: { idpIdentifier?: string; });
}

/**
 * Password Authentication information for a Company User or System User login.
 * 
 * Each company is seeded with a default password policy. In most test-scenarios, the passwordPolicyId field can be left unset which would
 * utilize the default policy of the Company. For more details on the default password policy - please refer to https://wiki.globalrelay.net/x/z2Y8Bw.
 * 
 * <dl>
 *  <dt>passwordPolicyId</dt><dd>ID of password policy to use. If not set, the default password policy of the user's company is used. Optional.</dd>
 *  <dt>password</dt><dd>The password hash of the login. Required.</dd>
 */
declare class PwdAuthStruct {
  public passwordPolicyId?: Int64;
  public passwordHash?: string;

    constructor(args?: { passwordPolicyId?: Int64; passwordHash?: string; });
}

/**
 * Authentication details used to create logins for a Company User.
 * 
 * One of samlAuth or pwdAuth must be specified to set the authentication method.
 * 
 * <dl>
 *  <dt>companyId</dt><dd>Company ID of the user. Required.</dd>
 *  <dt>companyUserId</dt><dd>ID of the company user to create a login for. Required.</dd>
 *  <dt>loginId</dt><dd>Login Identifier of the Company User. This can be a SAML ID or Email address. Required.</dd>
 *  <dt>samlAuth</dt><dd>Set login to use the SAML authentication.  Optional.</dd>
 *  <dt>pwdAuth</dt><dd>Set login to use password authentication. Optional.</dd>
 * </dl>
 */
declare class CompanyUserLoginStruct {
  public companyId?: number;
  public companyUserId?: Int64;
  public loginId?: string;
  public samlAuth?: SamlAuthStruct;
  public pwdAuth?: PwdAuthStruct;

    constructor(args?: { companyId?: number; companyUserId?: Int64; loginId?: string; samlAuth?: SamlAuthStruct; pwdAuth?: PwdAuthStruct; });
}

/**
 * Authentication details used to create logins for a System User.
 * 
 * <dl>
 *  <dt>companyId</dt><dd>Company ID of the system user. Required.</dd>
 *  <dt>systemUserId</dt><dd>ID of the system user to create a login for.  Required.</dd>
 *  <dt>loginId</dt><dd>Login identifier of the System User. Required.</dd>
 *  <dt>pwdAuth</dt><dd>Set login to use password authentication. Required.</dd>
 * </dl>
 */
declare class SystemUserLoginStruct {
  public companyId?: number;
  public systemUserId?: Int64;
  public loginId?: string;
  public pwdAuth?: PwdAuthStruct;

    constructor(args?: { companyId?: number; systemUserId?: Int64; loginId?: string; pwdAuth?: PwdAuthStruct; });
}

/**
 * Contact information for a given archive.
 * 
 * <dl>
 *  <dt>email</dt><dd>Email address list. Optional.</dd>
 *  <dt>emailBcc</dt><dd>BCC address list. Optional.</dd>
 * </dl>
 */
declare class ArchiveContactStruct {
  public email?: string;
  public emailBcc?: string;

    constructor(args?: { email?: string; emailBcc?: string; });
}

/**
 * Archive basic information.
 */
declare class ArchiveBasicStruct {
  public archiveId?: string;
  public name?: string;

    constructor(args?: { archiveId?: string; name?: string; });
}

/**
 * Profile for a company.
 * 
 * <dl>
 *   <dt>companyId</dt><dd>Service Manager ID of the company.</dd>
 *   <dt>companyName</dt><dd>Name of the company.</dd>
 *   <dt>addressLine1</dt><dd>Line 1 of the company address.</dd>
 *   <dt>addressLine2</dt><dd>Line 2 of the company address.</dd>
 *   <dt>city</dt><dd>City of the company.</dd>
 *   <dt>province</dt><dd>State of province of the company.</dd>
 *   <dt>postalCode</dt><dd>Postal code of the company.</dd>
 *   <dt>country</dt><dd>Country of the company.</dd>
 *   <dt>phoneNumber</dt><dd>Phone number of the company.</dd>
 *   <dt>website</dt><dd>Website of the company.</dd>
 *   <dt>email</dt><dd>Email of the company.</dd>
 *   <dt>companyLogo</dt><dd>Logo of the company, as a base64 image. Only used in test methods to set logo, use GetCompanyLogo to get logo.</dd>
 *   <dt>description</dt><dd>Description of the company. Can contain HTML markup.</dd>
 *   <dt>productsAndServices</dt><dd>Products and services of the company. Can contain HTML markup.</dd>
 *   <dt>companyLegalName</dt><dd>Legal name of the company.</dd>
 *   <dt>legalEntityIdentifier</dt><dd>Legal entity identifier (LEI) of the company.</dd>
 *   <dt>legalEntityName</dt><dd>Legal entity name of the company.</dd>
 *   <dt>logoVersion</dt><dd>The version number of the logo</dd>
 * </dl>
 */
declare class CompanyProfileStruct {
  public companyId?: number;
  public companyName?: string;
  public addressLine1?: string;
  public addressLine2?: string;
  public city?: string;
  public province?: string;
  public postalCode?: string;
  public country?: string;
  public phoneNumber?: string;
  public website?: string;
  public email?: string;
  public companyLogo?: string;
  public description?: string;
  public productsAndServices?: string;
  public companyLegalName?: string;
  public legalEntityIdentifier?: string;
  public legalEntityName?: string;
  public logoVersion?: number;

    constructor(args?: { companyId?: number; companyName?: string; addressLine1?: string; addressLine2?: string; city?: string; province?: string; postalCode?: string; country?: string; phoneNumber?: string; website?: string; email?: string; companyLogo?: string; description?: string; productsAndServices?: string; companyLegalName?: string; legalEntityIdentifier?: string; legalEntityName?: string; logoVersion?: number; });
}

/**
 * Basic Profile for a company.
 * 
 * <dl>
 *   <dt>companyLegalName</dt><dd>Legal name of the company.</dd>
 * </dl>
 */
declare class CompanyProfileBasicStruct {
  public companyLegalName?: string;

    constructor(args?: { companyLegalName?: string; });
}

/**
 * Logo for a company.
 * 
 * <dl>
 *   <dt>companyLogo</dt><dd>Logo of the company, as a base64 image.</dd>
 *   <dt>version</dt><dd>The version number of the logo</dd>
 *   <dt>logoMimeType</dt><dd>The MIME type of the logo image.</dd>
 *   <dt>useDefaultLogo</dt><dd>Boolean to identify the logo is not set. If true then MimeType and Image will be null.</dd>
 * </dl>
 */
declare class CompanyLogoStruct {
  public companyLogo?: string;
  public version?: number;
  public logoMimeType?: string;
  public useDefaultLogo?: boolean;

    constructor(args?: { companyLogo?: string; version?: number; logoMimeType?: string; useDefaultLogo?: boolean; });
}

/**
 * Reports-To property, containing basic information about the user. Used for both ReportsTo and Direct Reports information.
 * 
 * <dl>
 *   <dt>userId</dt><dd>SM User ID of the user.</dd>
 *   <dt>firstName</dt><dd>First name of the user.</dd>
 *   <dt>lastName</dt><dd>Last name of the user.</dd>
 *   <dt>emailAddresses</dt><dd>List of email addresses of the user.</dd>
 *   <dt>isEnabled</dt><dd>True if the user is enabled in Service Manager, false otherwise.</dd>
 * </dl>
 */
declare class ReportsToStruct {
  public userId?: Int64;
  public firstName?: string;
  public lastName?: string;
  public deprecated_emailAddresses?: string[];
  public isEnabled?: boolean;
  public email?: string;

    constructor(args?: { userId?: Int64; firstName?: string; lastName?: string; deprecated_emailAddresses?: string[]; isEnabled?: boolean; email?: string; });
}

/**
 * Settings for a specific profile attribute.
 * 
 * <dl>
 *   <dt>visibility</dt><dd>Visibility of the profile attribute.</dd>
 *   <dt>editability</dt><dd>Editability of the profile attribute.</dd>
 * </dl>
 */
declare class UserProfileAttributeSettingStruct {
  public visibility?: AttributeVisibility;
  public editability?: AttributeEditability;

    constructor(args?: { visibility?: AttributeVisibility; editability?: AttributeEditability; });
}

/**
 * A profile attribute for a user.
 * 
 * <dl>
 *   <dt>profileValue</dt><dd>Value of the user profile attribute.</dd>
 *   <dt>profileAttributeSettings</dt><dd>Effective settings of the user profile attribute.</dd>
 * </dl>
 */
declare class UserProfileAttributeValueStruct {
  public profileValue?: string;
  public profileAttributeSettings?: UserProfileAttributeSettingStruct;

    constructor(args?: { profileValue?: string; profileAttributeSettings?: UserProfileAttributeSettingStruct; });
}

/**
 * A profile attribute for a user.
 * 
 * <dl>
 *   <dt>profileValue</dt><dd>Value of the user profile attribute.</dd>
 *   <dt>profileAttributeSettings</dt><dd>Effective settings of the user profile attribute.</dd>
 * </dl>
 */
declare class UserProfileAttributeCollectionValueStruct {
  public profileValues?: string[];
  public profileAttributeSettings?: UserProfileAttributeSettingStruct;

    constructor(args?: { profileValues?: string[]; profileAttributeSettings?: UserProfileAttributeSettingStruct; });
}

/**
 * Collection of user profile attributes that can be set by a user.
 * 
 * <dl>
 *   <dt>firstName</dt><dd>First name of the user.</dd>
 *   <dt>lastName</dt><dd>Last name of the user.</dd>
 *   <dt>customerUserId</dt><dd>Customer User ID of the user.</dd>
 *   <dt>jobTitle</dt><dd>Job title of the user.</dd>
 *   <dt>workPhone</dt><dd>Work phone of the user.</dd>
 *   <dt>mobilePhone</dt><dd>Mobile phone of the user.</dd>
 *   <dt>homePhone</dt><dd>Home phone of the user.</dd>
 *   <dt>reportToUserId</dt><dd>The SM user ID of the user in the "reports to" profile attribute.</dd>
 *   <dt>location</dt><dd>User's current location.</dd>
 *   <dt>reportsToEditability</dt><dd>User's reports-to editability setting.</dd>
 *   <dt>addressLine1</dt><dd>User's address line 1.</dd>
 *   <dt>addressLine2</dt><dd>User's address line 2.</dd>
 *   <dt>city</dt><dd>User's city.</dd>
 *   <dt>province</dt><dd>User's province.</dd>
 *   <dt>postalCode</dt><dd>User's postal code.</dd>
 *   <dt>country</dt><dd>User's country.</dd>
 * </dl>
 */
declare class UserProfileUserSetAttributesStruct {
  public firstName?: UserProfileAttributeValueStruct;
  public lastName?: UserProfileAttributeValueStruct;
  public customerUserId?: UserProfileAttributeValueStruct;
  public jobTitle?: UserProfileAttributeValueStruct;
  public workPhone?: UserProfileAttributeValueStruct;
  public mobilePhone?: UserProfileAttributeValueStruct;
  public homePhone?: UserProfileAttributeValueStruct;
  public reportsToUser?: ReportsToStruct;
  public location?: UserProfileAttributeValueStruct;
  public obsolete_nickname?: UserProfileAttributeValueStruct;
  public reportsToEditability?: AttributeEditability;
  public addressLine1?: UserProfileAttributeValueStruct;
  public addressLine2?: UserProfileAttributeValueStruct;
  public city?: UserProfileAttributeValueStruct;
  public province?: UserProfileAttributeValueStruct;
  public postalCode?: UserProfileAttributeValueStruct;
  public country?: UserProfileAttributeValueStruct;
  public deprecated_emailAddresses?: UserProfileAttributeCollectionValueStruct;
  public email?: UserProfileAttributeValueStruct;

    constructor(args?: { firstName?: UserProfileAttributeValueStruct; lastName?: UserProfileAttributeValueStruct; customerUserId?: UserProfileAttributeValueStruct; jobTitle?: UserProfileAttributeValueStruct; workPhone?: UserProfileAttributeValueStruct; mobilePhone?: UserProfileAttributeValueStruct; homePhone?: UserProfileAttributeValueStruct; reportsToUser?: ReportsToStruct; location?: UserProfileAttributeValueStruct; obsolete_nickname?: UserProfileAttributeValueStruct; reportsToEditability?: AttributeEditability; addressLine1?: UserProfileAttributeValueStruct; addressLine2?: UserProfileAttributeValueStruct; city?: UserProfileAttributeValueStruct; province?: UserProfileAttributeValueStruct; postalCode?: UserProfileAttributeValueStruct; country?: UserProfileAttributeValueStruct; deprecated_emailAddresses?: UserProfileAttributeCollectionValueStruct; email?: UserProfileAttributeValueStruct; });
}

/**
 * Profile policy for a company
 * 
 * <dl>
 *   <dt>version</dt><dd>The current profile policy version.</dd>
 *   <dt>address</dt><dd>Address policy settings.</dd>
 *   <dt>avatar</dt><dd>Avatar policy settings.</dd>
 *   <dt>company</dt><dd>Company policy settings.</dd>
 *   <dt>emailAddresses</dt><dd>EmailAddresses policy settings.</dd>
 *   <dt>grid</dt><dd>GRID policy settings.</dd>
 *   <dt>homePhone</dt><dd>HomePhone policy settings.</dd>
 *   <dt>jobTitle</dt><dd>JobTitle policy settings.</dd>
 *   <dt>mobilePhone</dt><dd>MobilePhone policy settings.</dd>
 *   <dt>location</dt><dd>Location policy settings.</dd>
 *   <dt>name</dt><dd>Name policy settings.</dd>
 *   <dt>reportsTo</dt><dd>ReportsTo policy settings.</dd>
 *   <dt>customerUserId</dt><dd>CustomerUserId policy settings.</dd>
 *   <dt>workPhone</dt><dd>WorkPhone policy settings.</dd>
 * </dl>
 */
declare class ProfilePolicyStruct {
  public version?: Int64;
  public address?: UserProfileAttributeSettingStruct;
  public avatar?: UserProfileAttributeSettingStruct;
  public company?: UserProfileAttributeSettingStruct;
  public email?: UserProfileAttributeSettingStruct;
  public grid?: UserProfileAttributeSettingStruct;
  public homePhone?: UserProfileAttributeSettingStruct;
  public jobTitle?: UserProfileAttributeSettingStruct;
  public mobilePhone?: UserProfileAttributeSettingStruct;
  public location?: UserProfileAttributeSettingStruct;
  public name?: UserProfileAttributeSettingStruct;
  public reportsTo?: UserProfileAttributeSettingStruct;
  public customerUserId?: UserProfileAttributeSettingStruct;
  public workPhone?: UserProfileAttributeSettingStruct;

    constructor(args?: { version?: Int64; address?: UserProfileAttributeSettingStruct; avatar?: UserProfileAttributeSettingStruct; company?: UserProfileAttributeSettingStruct; email?: UserProfileAttributeSettingStruct; grid?: UserProfileAttributeSettingStruct; homePhone?: UserProfileAttributeSettingStruct; jobTitle?: UserProfileAttributeSettingStruct; mobilePhone?: UserProfileAttributeSettingStruct; location?: UserProfileAttributeSettingStruct; name?: UserProfileAttributeSettingStruct; reportsTo?: UserProfileAttributeSettingStruct; customerUserId?: UserProfileAttributeSettingStruct; workPhone?: UserProfileAttributeSettingStruct; });
}

/**
 * Profile for a user.
 * 
 * <dl>
 *   <dt>userId</dt><dd>Service Manager ID of the user.</dd>
 *   <dt>userSetAttributes</dt><dd>Collection of user profile attributes that are (potentially) set by the user.</dd>
 *   <dt>grid</dt><dd>GRID of the user.</dd>
 *   <dt>emailAddresses</dt><dd>Collection of email addresses of the user.</dd>
 *   <dt>directReports</dt><dd>List of other users who directly report to the user. Limited to 3 direct reports returned.</dd>
 *   <dt>isDirectReportsTruncated</dt><dd>True if there are additional direct reports that were not included in the result. False otherwise.</dd>
 *   <dt>companyName</dt><dd>The user's company friendly name.</dd>
 *   <dt>companyLegalName</dt><dd>The user's company legal name.</dd>
 *   <dt>companyAddressLine1</dt><dd>The user's company address line 1.</dd>
 *   <dt>companyAddressLine2</dt><dd>The user's company address line 2.</dd>
 *   <dt>companyCity</dt><dd>The user's company city name.</dd>
 *   <dt>companyProvince</dt><dd>The user's company province name.</dd>
 *   <dt>companyPostalCode</dt><dd>The user's company postalCode.</dd>
 *   <dt>companyCountry</dt><dd>The user's company country name.</dd>
 *   <dt>companyPhoneNumber</dt><dd>The user's company phone number.</dd>
 *   <dt>companyEmail</dt><dd>The user's company email.</dd>
 *   <dt>companyDateModified</dt><dd>Either the DateModified of the Company or the CompanyProfile, whichever is more recent.</dd>
 *   <dt>companyId</dt><dd>Service Manager ID of the company.</dd>
 *   <dt>profileVersion</dt><dd>User profile version.</dd>
 *   <dt>profilePolicyVersion</dt><dd>User profile version.</dd>
 *   <dt>legalEntityIdentifier</dt><dd>Legal entity identifier (LEI) of the company.</dd>
 * </dl>
 */
declare class UserProfileStruct {
  public userId?: Int64;
  public userSetAttributes?: UserProfileUserSetAttributesStruct;
  public grid?: string;
  public deprecated_emailAddresses?: string[];
  public directReports?: ReportsToStruct[];
  public isDirectReportsTruncated?: boolean;
  public companyName?: string;
  public companyLegalName?: string;
  public companyAddressLine1?: string;
  public companyAddressLine2?: string;
  public companyCity?: string;
  public companyProvince?: string;
  public companyPostalCode?: string;
  public companyCountry?: string;
  public companyPhoneNumber?: string;
  public companyEmail?: string;
  public companyDateModified?: Int64;
  public companyId?: number;
  public profileVersion?: Int64;
  public profilePolicyVersion?: Int64;
  public legalEntityIdentifier?: string;
  public email?: string;

    constructor(args?: { userId?: Int64; userSetAttributes?: UserProfileUserSetAttributesStruct; grid?: string; deprecated_emailAddresses?: string[]; directReports?: ReportsToStruct[]; isDirectReportsTruncated?: boolean; companyName?: string; companyLegalName?: string; companyAddressLine1?: string; companyAddressLine2?: string; companyCity?: string; companyProvince?: string; companyPostalCode?: string; companyCountry?: string; companyPhoneNumber?: string; companyEmail?: string; companyDateModified?: Int64; companyId?: number; profileVersion?: Int64; profilePolicyVersion?: Int64; legalEntityIdentifier?: string; email?: string; });
}

/**
 * Auto-complete result.
 * 
 * <dl>
 *   <dt>userId</dt><dd>Service Manager ID of the user.</dd>
 *   <dt>firstName</dt><dd>User's first name.</dd>
 *   <dt>lastName</dt><dd>User's last name.</dd>
 *   <dt>email</dt><dd>An email address of the user. Used to distinguish users who may have the same first and last name.</dd>
 * </dl>
 */
declare class UserAutoCompleteResultStruct {
  public userId?: Int64;
  public firstName?: string;
  public lastName?: string;
  public email?: string;

    constructor(args?: { userId?: Int64; firstName?: string; lastName?: string; email?: string; });
}

/**
 * Communication platform details. Will include message types in future.
 */
declare class CommunicationPlatformStruct {
  public name?: string;
  public code?: string;
  public deliveryTypes?: string[];

    constructor(args?: { name?: string; code?: string; deliveryTypes?: string[]; });
}

/**
 * Company communication platform details.
 */
declare class CompanyCommunicationPlatformStruct {
  public id?: number;
  public communicationPlatform?: CommunicationPlatformStruct;

    constructor(args?: { id?: number; communicationPlatform?: CommunicationPlatformStruct; });
}

/**
 * <dl>
 *  <dt>userAliases</dt><dd>User aliases found matching the search criteria. Can be empty.</dd>
 *  <dt>totalResultsFound</dt><dd>The total number of results found matching the criteria.</dd>
 * </dl>
 */
declare class FindUserAliasesResultStruct {
  public userAliases: UserAliasStruct[];
  public totalResultsFound?: number;

    constructor(args?: { userAliases: UserAliasStruct[]; totalResultsFound?: number; });
}

/**
 * Struct that contains role information.
 * <dl>
 *   <dt>roleId</dt><dd>Service Manager ID for the role.</dd>
 *   <dt>roleName</dt><dd>Name of the role.</dd>
 *   <dt>entitlements</dt><dd>List of roles entitlements.</dd>
 * </dl>
 */
declare class RoleStruct {
  public roleId?: Int64;
  public roleName?: string;
  public entitlements?: string[];

    constructor(args?: { roleId?: Int64; roleName?: string; entitlements?: string[]; });
}

/**
 * Struct that contains application instance information.
 * <dl>
 *   <dt>applicationName</dt><dd>The name of the application.</dd>
 *   <dt>companyId</dt><dd>The SM comany Id of the company. It is required for SeriveManager and Directory applications.</dd>
 *   <dt>archiveId</dt><dd>The archive Id of the archive application instance. It is required for Archive application.</dd>
 * </dl>
 */
declare class ApplicationInstanceStruct {
  public applicationName?: ApplicationName;
  public companyId?: number;
  public archiveId?: string;

    constructor(args?: { applicationName?: ApplicationName; companyId?: number; archiveId?: string; });
}

declare class GroupInformationStruct {
  public companyId?: number;
  public groupId?: number;
  public groupName?: string;
  public isDeactivated?: boolean;
  public groupDisplayName?: string;

    constructor(args?: { companyId?: number; groupId?: number; groupName?: string; isDeactivated?: boolean; groupDisplayName?: string; });
}

declare class SocialMediaAccessTokenStruct {
  public SocialMediaAccountId?: string;
  public Token?: string;
  public TokenSecret?: string;
  public DateExpires?: Int64;
  public ScreenName?: string;
  public DisplayName?: string;
  public OAuthVersion?: number;

    constructor(args?: { SocialMediaAccountId?: string; Token?: string; TokenSecret?: string; DateExpires?: Int64; ScreenName?: string; DisplayName?: string; OAuthVersion?: number; });
}

declare class AccessRightsStruct {
  public systemFolderName?: string;
  public userId?: Int64;
  public mailboxId?: Int64;
  public caseName?: string;

    constructor(args?: { systemFolderName?: string; userId?: Int64; mailboxId?: Int64; caseName?: string; });
}

/**
 * The entitlement actor is privileged to within application, function or with function resource.
 */
declare class EntitlementStruct {
  public symbolicName?: string;

    constructor(args?: { symbolicName?: string; });
}

/**
 * This struct contains all ControlCenter security values
 * 
 */
declare class ControlCenterCompanySecurityStruct {
  public MobileSessionTimeout?: number;
  public NonMobileSessionTimeout?: number;

    constructor(args?: { MobileSessionTimeout?: number; NonMobileSessionTimeout?: number; });
}

/**
 * This struct contains all ControlCenter configuration values
 * 
 */
declare class ControlCenterCompanyStruct {
  public companyId?: string;
  public DisplayName?: string;
  public CompanyName?: string;
  public Country?: string;
  public City?: string;
  public PhoneNumber?: string;
  public PostalCode?: string;
  public Province?: string;
  public Street?: string;
  public FaxNumber?: string;
  public Email?: string;
  public domains?: string[];
  public authenticationType?: AuthenticationType;
  public security?: ControlCenterCompanySecurityStruct;

    constructor(args?: { companyId?: string; DisplayName?: string; CompanyName?: string; Country?: string; City?: string; PhoneNumber?: string; PostalCode?: string; Province?: string; Street?: string; FaxNumber?: string; Email?: string; domains?: string[]; authenticationType?: AuthenticationType; security?: ControlCenterCompanySecurityStruct; });
}

/**
 * This struct allows for the creation of an extended property
 * 
 * templateName valid values: 'FXT Matching Site ID(s)', 'FXT Dealing Desk(s)', 'FXT Dealing User ID(s)' or 'FXT Matching User ID(s)'
 * 
 * Providing the templateName and companyId will create an extended property according to the built in platform template. Other values provided will be ignored.
 * Not providing templateName will create an extedend property according to the other values provided.
 * 
 */
declare class CreateExtendedPropertyStruct {
  public name?: string;
  public companyId?: number;
  public dataType?: string;
  public supportsMultiple?: boolean;
  public isCompanyUnique?: boolean;
  public templateName?: string;
  public isApplicableToUser?: boolean;
  public isApplicableToSharedMailbox?: boolean;
  public isApplicableToGroup?: boolean;

    constructor(args?: { name?: string; companyId?: number; dataType?: string; supportsMultiple?: boolean; isCompanyUnique?: boolean; templateName?: string; isApplicableToUser?: boolean; isApplicableToSharedMailbox?: boolean; isApplicableToGroup?: boolean; });
}

/**
 * This struct allows for the enabling of a service for a company.
 * 
 * <dl>
 *   <dt>companyId</dt><dd>The id of the company. Required</dd>
 *   <dt>serviceSku</dt><dd>The Sku of the service. Required</dd>
 *   <dt>hsmPartitionReference</dt><dd>The HSM Partition Reference. Optional, required only for Advanced Key Control.</dd>
 * </dl>
 */
declare class EnableCompanyServiceStruct {
  public companyId?: number;
  public serviceSku?: ServiceSku;
  public hsmPartitionReference?: string;

    constructor(args?: { companyId?: number; serviceSku?: ServiceSku; hsmPartitionReference?: string; });
}

/**
 * service configuration struct.
 * 
 *  <dl>
 *   <dt>companyId</dt><dd>The id of the company. Required</dd>
 *   <dt>systemUserLogin</dt><dd>System user login</dd>
 *  <dt>region</dt><dd>Data center region</dd>
 *  </dl>
 */
declare class ServiceConfigurationStruct {
  public companyId?: number;
  public systemUserLogin?: string;
  public region?: RegionType;

    constructor(args?: { companyId?: number; systemUserLogin?: string; region?: RegionType; });
}

/**
 * ApplicationRoleAssignmentConstraintStruct struct.
 * 
 *  <dl>
 *   <dt>messageFeedId</dt><dd>The messageFeedId of the message feed. Optional</dd>
 *   <dt>websiteCrawlingUrlId</dt><dd>The crawlingUrlId of the websiteCrawlingUrl. Optional</dd>
 *  </dl>
 */
declare class ApplicationRoleAssignmentConstraintStruct {
  public messageFeedId?: string;
  public websiteCrawlingUrlId?: string;
  public deviceSymbolicName?: string;

    constructor(args?: { messageFeedId?: string; websiteCrawlingUrlId?: string; deviceSymbolicName?: string; });
}

/**
 * EntitlementWithConstraintStruct struct.
 * 
 *  <dl>
 *   <dt>symbolicName</dt><dd>symbolic name of the entitlement. Required</dd>
 *   <dt>ApplicationRoleAssignmentConstraintStruct</dt><dd>struct containing the id of the constrained entity. Optional</dd>
 *  </dl>
 */
declare class EntitlementWithConstraintStruct {
  public symbolicName?: string;
  public constraint?: ApplicationRoleAssignmentConstraintStruct;

    constructor(args?: { symbolicName?: string; constraint?: ApplicationRoleAssignmentConstraintStruct; });
}

declare class MessageAccessExclusionStruct {
  public excludeOwnReceivedMessage?: boolean;
  public excludeOwnSentMessage?: boolean;
  public archiveId?: string;
  public functionId?: number;

    constructor(args?: { excludeOwnReceivedMessage?: boolean; excludeOwnSentMessage?: boolean; archiveId?: string; functionId?: number; });
}

/**
 * Generic exception for error not defined in a more specific exception.
 * If a Service Manager validation exception - the entity, property, and validation message will be returned in detailed JSON format inside the description.
 */
declare class FailureException extends Thrift.TException {
  public description?: string;

    constructor(args?: { description?: string; });
}

/**
 * Exception returned when trying to perform any action using a user id that does not exist in the Service Manager database.
 * This can be returned from several RPC calls including those related to users, avatar, rosters, and profile cards (as they all take in userId as a parameter).
 */
declare class UserNotFoundException extends Thrift.TException {
  public userId?: Int64;

    constructor(args?: { userId?: Int64; });
}

/**
 * Exception returned when trying to perform any action using a system user id that does not exist in the Service Manager database.
 */
declare class SystemUserNotFoundException extends Thrift.TException {
  public userId?: Int64;

    constructor(args?: { userId?: Int64; });
}

/**
 * Exception returned when a user alias is not found.
 */
declare class UserAliasNotFoundException extends Thrift.TException {
  public userAliasId?: Int64;

    constructor(args?: { userAliasId?: Int64; });
}

/**
 * Exception returned when a user alias is valid for use as mailbox recovery address (is deactivated or not of 'email' type).
 */
declare class UserAliasNotValidMailboxRecoveryAddressException extends Thrift.TException {
  public userAliasId?: Int64;

    constructor(args?: { userAliasId?: Int64; });
}

/**
 * Exception returned when general RBAC error occurs
 */
declare class RbacException extends Thrift.TException {
  public description?: string;

    constructor(args?: { description?: string; });
}

declare class CompanyNotFoundException extends Thrift.TException {
}

declare class GroupNotFoundException extends Thrift.TException {
}

declare class GroupAlreadyExistsException extends Thrift.TException {
  public groupId: number;

    constructor(args?: { groupId: number; });
}

declare class CompanyAlreadyExistsException extends Thrift.TException {
  public companyId: number;

    constructor(args?: { companyId: number; });
}

declare class InvalidUserCountException extends Thrift.TException {
}

declare class UserCountTooLargeException extends Thrift.TException {
  public maxUsers: number;

    constructor(args?: { maxUsers: number; });
}

declare class ArchiveNotFoundException extends Thrift.TException {
}

/**
 * Exception thrown when Service Manager cannot update user profile settings
 * based on the company's user profile policy
 */
declare class UserProfileEditabilityException extends Thrift.TException {
}

/**
 * Exception thrown when a basic or advanced search contains an invalid criteria
 */
declare class InvalidSearchCriteriaException extends Thrift.TException {
}

declare class CompanyExtendedUserPropertyNotFoundException extends Thrift.TException {
  public companyId?: number;
  public entityDisplayName?: string;
  public propertyName?: string;

    constructor(args?: { companyId?: number; entityDisplayName?: string; propertyName?: string; });
}

declare class CommunicationPlatformNotFoundException extends Thrift.TException {
}

declare class CompanyApplicationNotFoundException extends Thrift.TException {
}

declare class ApplicationInstanceNotFoundException extends Thrift.TException {
}

declare class RoleNotFoundException extends Thrift.TException {
}

declare class OperationNotFoundException extends Thrift.TException {
}

/**
 * *
 * The API version included on every request in the X-GR-API-VERSION header
 */
declare var X_GR_API_VERSION_VALUE: string;

declare var DELIVERY_TYPE_COLLECT: string;

declare var DELIVERY_TYPE_RECEIVE: string;
