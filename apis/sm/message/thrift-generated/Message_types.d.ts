//
// Autogenerated by Thrift Compiler (0.16.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
import thrift = require('thrift');
import Thrift = thrift.Thrift;
import Q = thrift.Q;
import Int64 = require('node-int64');


declare enum PresenceSharingLevel {
  FULL = 0,
  SIMPLE = 1,
}

declare enum RosterEntryOperation {
  ADD = 0,
  DELETE = 1,
  MODIFY = 2,
}

/**
 */
declare enum AliasType {
  GRCP = 0,
  EMAIL = 2,
}

/**
 * Editability of the profile attribute.
 * 
 * <dl>
 *   <dt>NONE</dt><dd>Attribute is not editable.</dd>
 *   <dt>TIGHT</dt><dd>Attribute is tightly coupled, i.e. updating the user account record will update the user profile attribute and vice-versa.</dd>
 *   <dt>LOOSE</dt><dd>Attribute is loosely coupled, i.e. the user account record and user profile attribute can be updated independently.</dd>
 * </dl>
 */
declare enum AttributeEditability {
  NONE = 1,
  TIGHT = 2,
  LOOSE = 3,
}

/**
 * Visibility of the profile attribute.
 * 
 * <dl>
 *   <dt>PUBLIC</dt><dd>Visible to all users.</dd>
 *   <dt>COMPANY</dt><dd>Only visible to users within the same company.</dd>
 * </dl>
 */
declare enum AttributeVisibility {
  PUBLIC = 1,
  COMPANY = 2,
}

/**
 * This struct can be used when creating test users to set their name properties.
 * 
 * <dl>
 *  <dt>firstName</dt><dd>User's first name.  Required.</dd>
 *  <dt>lastName</dt><dd>User's last name.  Required.</dd>
 *  <dt>middleInitial</dt><dd>User's middle initial.  Optional.</dd>
 *  <dt>email</dt><dd>User's email.  Optional.</dd>
 * </dl>
 */
declare class UserNameStruct {
  public firstName: string;
  public lastName: string;
  public middleInitial?: string;
  public email?: string;

    constructor(args?: { firstName: string; lastName: string; middleInitial?: string; email?: string; });
}

/**
 * <dl>
 *  <dt>userId</dt><dd>Service Manager's User Id.  Unique Id of the User entity.</dd>
 *  <dt>grcpAlias</dt><dd>GRCP alias, such as 88@globalrelay.local.  The grcp alias is unique for the user (for life).</dd>
 * </dl>
 */
declare class UserStruct {
  public userId: Int64;
  public grcpAlias: string;
  public userName: UserNameStruct;

    constructor(args?: { userId: Int64; grcpAlias: string; userName: UserNameStruct; });
}

/**
 * This struct is used when setting the avatar structure.
 * 
 * <dl>
 *  <dt>sourceImageMimeType</dt><dd>Mime type of the original source image (not used for display)</dd>
 *  <dt>sourceImage</dt><dd>Base64 string of the original source image (not used for display).  This is the image that user web will convert into Avatar and Avatar Thumbnail.  (may convert back to byte array after Thrift is upgraded to 0.7 on Message system)</dd>
 *  <dt>avatarMimeType</dt><dd>Mime type of the larger image for display in the Profile Card.</dd>
 *  <dt>avatarImage</dt><dd>Base64 string of the larger image for display in the Profile Card.  (may convert back to byte array after Thrift is upgraded to 0.7 on Message system)</dd>
 *  <dt>avatarThumbnailMimeType</dt><dd>Mime type of the smaller image for display next to Roster Entries and the header bar.</dd>
 *  <dt>avatarThumbnailImage</dt><dd>Base64 string of the smaller image for display next to Roster Entries and the header bar.  (may convert back to byte array after Thrift is upgraded to 0.7 on Message system)</dd>
 * </dl>
 */
declare class AvatarSetStruct {
  public sourceImageMimeType: string;
  public sourceImage: string;
  public avatarMimeType: string;
  public avatarImage: string;
  public avatarThumbnailMimeType: string;
  public avatarThumbnailImage: string;

    constructor(args?: { sourceImageMimeType: string; sourceImage: string; avatarMimeType: string; avatarImage: string; avatarThumbnailMimeType: string; avatarThumbnailImage: string; });
}

/**
 * This struct is used when getting any avatar (large) or avatar thumbnail (small) image
 * 
 * <dl>
 *  <dt>mimeType</dt><dd>Mime type of the image.  Will be null if defaultAvatar is true.</dd>
 *  <dt>version</dt><dd>Incrementing version specifically for avatar and thumbnail images.  Begins at 1 and is incremented by 1 on every avatar or thumbnail change.  Is not incremented on source image changes (as it is not displayed).</dd>
 *  <dt>image</dt><dd>Base64 string of the image.  Will be null if defaultAvatar is true.  (may convert back to byte array after Thrift is upgraded to 0.7 on Message system)</dd>
 *  <dt>defaultAvatar</dt><dd>Boolean to identify the avatar is not set.  In this case, the default avatar or default avatar thumbnail should be used.  If the default avatar, the MimeType and Image will be null.</dd>
 * </dl>
 */
declare class AvatarStruct {
  public mimeType?: string;
  public version: number;
  public image?: string;
  public defaultAvatar: boolean;

    constructor(args?: { mimeType?: string; version: number; image?: string; defaultAvatar: boolean; });
}

/**
 * * <dl>
 * *  <dt>grcpOrSipId</dt><dd>required, primary key for a roster entry for GRCP clients.
 *     This could be a grcpAlias for a GRMsg user or a sipAlias for a SIP user.
 * 	Sip aliases will always be prefixed by "sip:".  Service Manager will use this prefix to determine user alias type.</dd>
 * *  <dt>systemTag</dt><dd>required unless Deleted is true. May be an empty list</dd>
 * *  <dt>userTags</dt><dd>required unless Deleted is true. May be an empty list</dd>
 * *  <dt>presenceSharing</dt><dd>required unless Deleted is true</dd>
 * *  <dt>firstName</dt><dd>first name of the roster entry user</dd>
 * *  <dt>lastName</dt><dd>last name of the roster entry user</dd>
 * *  <dt>middleInitial</dt><dd>middle initial of the roster entry user, if exists</dd>
 * *  <dt>nickname</dt><dd>nickname of the roster entry user, if exists</dd>
 * *  <dt>companyName</dt><dd>company the roster entry user works for</dd>
 * *  <dt>versionUpdated</dt><dd>must be absent for updates, required in roster fetches from SM</dd>
 * *  <dt>deleted</dt><dd>must be absent for updates, required in roster entry values returned from SM</dd>
 * *  <dt>enabled</dt><dd>specifies whether roster entry is enabled or disabled</dd>
 * *  <dt>avatarVersion</dt><dd>Incrementing version specifically for avatar and thumbnail images. Value returned in getRosterUpdates. This value is not used when updating a roster.</dd>
 * * </dl>
 */
declare class RosterEntryStruct {
  public grcpOrSipId: string;
  public systemTags?: string[];
  public userTags?: string[];
  public presenceSharing: PresenceSharingLevel;
  public firstName?: string;
  public lastName?: string;
  public middleInitial?: string;
  public nickname?: string;
  public companyName?: string;
  public versionUpdated?: Int64;
  public deleted?: boolean;
  public enabled?: boolean;
  public avatarVersion?: number;

    constructor(args?: { grcpOrSipId: string; systemTags?: string[]; userTags?: string[]; presenceSharing: PresenceSharingLevel; firstName?: string; lastName?: string; middleInitial?: string; nickname?: string; companyName?: string; versionUpdated?: Int64; deleted?: boolean; enabled?: boolean; avatarVersion?: number; });
}

/**
 * <dl>
 *  <dt>version</dt><dd>Version of the Roster.  Incremented by 1 with each roster entry (or tag) create, update, or delete.</dd>
 *  <dt>entries</dt>
 * <dd>List of roster entries belonging to the user's Roster.  See RosterEntryStruct comments for details.
 * 	When calling getRoster this is a list of all entries in the roster.
 * 	When calling getRosterUpdates this is a list of all adds, updates, or deletes since specified roster version.
 *  </dd>
 * </dl>
 */
declare class RosterStruct {
  public version: Int64;
  public entries: RosterEntryStruct[];

    constructor(args?: { version: Int64; entries: RosterEntryStruct[]; });
}

/**
 * <dl>
 *  <dt>operation</dt><dd>Operation to be performed on the roster entry (add, modify, or delete).</dd>
 *  <dt>entries</dt><dd>A roster entry belonging to the user's Roster.  See RosterEntryStruct comments for details.</dd>
 * </dl>
 */
declare class RosterEntryDeltaStruct {
  public operation: RosterEntryOperation;
  public rosterEntry: RosterEntryStruct;

    constructor(args?: { operation: RosterEntryOperation; rosterEntry: RosterEntryStruct; });
}

/**
 * <dl>
 *  <dt>tags</dt><dd>Tags to further identify the string value.  For example, the string value could represent a phone number that is tagged with "Business" and "Mobile"</dd>
 *  <dt>value</dt><dd>A string value, such as a phone number, that can have one or more tags.</dd>
 * </dl>
 */
declare class TaggedStringStruct {
  public tags: string[];
  public value: string;

    constructor(args?: { tags: string[]; value: string; });
}

declare class AliasStruct {
  public aliasType: AliasType;
  public aliasValue: string;

    constructor(args?: { aliasType: AliasType; aliasValue: string; });
}

/**
 * Reports-To property, containing basic information about the user. Used for both ReportsTo and Direct Reports information.
 * 
 * <dl>
 *   <dt>userId</dt><dd>SM User ID of the user.</dd>
 *   <dt>firstName</dt><dd>First name of the user.</dd>
 *   <dt>lastName</dt><dd>Last name of the user.</dd>
 *   <dt>isEnabled</dt><dd>True if the user is enabled in Service Manager, false otherwise.</dd>
 *   <dt>email</dt><dd>Email address of the user.</dd>
 * </dl>
 */
declare class ReportsToStruct {
  public userId?: Int64;
  public firstName?: string;
  public lastName?: string;
  public isEnabled?: boolean;
  public email?: string;

    constructor(args?: { userId?: Int64; firstName?: string; lastName?: string; isEnabled?: boolean; email?: string; });
}

/**
 * Settings for a specific profile attribute.
 * 
 * <dl>
 *   <dt>visibility</dt><dd>Visibility of the profile attribute.</dd>
 *   <dt>editability</dt><dd>Editability of the profile attribute.</dd>
 * </dl>
 */
declare class UserProfileAttributeSettingStruct {
  public visibility?: AttributeVisibility;
  public editability?: AttributeEditability;

    constructor(args?: { visibility?: AttributeVisibility; editability?: AttributeEditability; });
}

/**
 * A profile attribute for a user.
 * 
 * <dl>
 *   <dt>profileValue</dt><dd>Value of the user profile attribute.</dd>
 *   <dt>profileAttributeSettings</dt><dd>Effective settings of the user profile attribute.</dd>
 * </dl>
 */
declare class UserProfileAttributeValueStruct {
  public profileValue?: string;
  public profileAttributeSettings?: UserProfileAttributeSettingStruct;

    constructor(args?: { profileValue?: string; profileAttributeSettings?: UserProfileAttributeSettingStruct; });
}

/**
 * A profile attribute for a user.
 * 
 * <dl>
 *   <dt>profileValue</dt><dd>Value of the user profile attribute.</dd>
 *   <dt>profileAttributeSettings</dt><dd>Effective settings of the user profile attribute.</dd>
 * </dl>
 */
declare class UserProfileAttributeCollectionValueStruct {
  public profileValues?: string[];
  public profileAttributeSettings?: UserProfileAttributeSettingStruct;

    constructor(args?: { profileValues?: string[]; profileAttributeSettings?: UserProfileAttributeSettingStruct; });
}

/**
 * Collection of user profile attributes that can be set by a user.
 * 
 * <dl>
 *   <dt>firstName</dt><dd>First name of the user.</dd>
 *   <dt>lastName</dt><dd>Last name of the user.</dd>
 *   <dt>customerUserId</dt><dd>Customer User ID of the user.</dd>
 *   <dt>jobTitle</dt><dd>Job title of the user.</dd>
 *   <dt>workPhone</dt><dd>Work phone of the user.</dd>
 *   <dt>mobilePhone</dt><dd>Mobile phone of the user.</dd>
 *   <dt>homePhone</dt><dd>Home phone of the user.</dd>
 *   <dt>reportToUserId</dt><dd>The SM user ID of the user in the "reports to" profile attribute.</dd>
 *   <dt>location</dt><dd>User's current location.</dd>
 *   <dt>reportsToEditability</dt><dd>User's reports-to editability setting.</dd>
 *   <dt>addressLine1</dt><dd>User's address line 1.</dd>
 *   <dt>addressLine2</dt><dd>User's address line 2.</dd>
 *   <dt>city</dt><dd>User's city.</dd>
 *   <dt>province</dt><dd>User's province.</dd>
 *   <dt>postalCode</dt><dd>User's postal code.</dd>
 *   <dt>country</dt><dd>User's country.</dd>
 *   <dt>email</dt><dd>Email address of the user.</dd>
 * </dl>
 */
declare class UserProfileUserSetAttributesStruct {
  public firstName?: UserProfileAttributeValueStruct;
  public lastName?: UserProfileAttributeValueStruct;
  public customerUserId?: UserProfileAttributeValueStruct;
  public jobTitle?: UserProfileAttributeValueStruct;
  public workPhone?: UserProfileAttributeValueStruct;
  public mobilePhone?: UserProfileAttributeValueStruct;
  public homePhone?: UserProfileAttributeValueStruct;
  public reportsToUser?: ReportsToStruct;
  public location?: UserProfileAttributeValueStruct;
  public obsolete_nickname?: UserProfileAttributeValueStruct;
  public reportsToEditability?: AttributeEditability;
  public addressLine1?: UserProfileAttributeValueStruct;
  public addressLine2?: UserProfileAttributeValueStruct;
  public city?: UserProfileAttributeValueStruct;
  public province?: UserProfileAttributeValueStruct;
  public postalCode?: UserProfileAttributeValueStruct;
  public country?: UserProfileAttributeValueStruct;
  public email?: UserProfileAttributeValueStruct;

    constructor(args?: { firstName?: UserProfileAttributeValueStruct; lastName?: UserProfileAttributeValueStruct; customerUserId?: UserProfileAttributeValueStruct; jobTitle?: UserProfileAttributeValueStruct; workPhone?: UserProfileAttributeValueStruct; mobilePhone?: UserProfileAttributeValueStruct; homePhone?: UserProfileAttributeValueStruct; reportsToUser?: ReportsToStruct; location?: UserProfileAttributeValueStruct; obsolete_nickname?: UserProfileAttributeValueStruct; reportsToEditability?: AttributeEditability; addressLine1?: UserProfileAttributeValueStruct; addressLine2?: UserProfileAttributeValueStruct; city?: UserProfileAttributeValueStruct; province?: UserProfileAttributeValueStruct; postalCode?: UserProfileAttributeValueStruct; country?: UserProfileAttributeValueStruct; email?: UserProfileAttributeValueStruct; });
}

/**
 * <dl>
 *  <dt>version</dt><dd>An incremented number to easily identify Profiles with updated values. A Profile will have it's Version number incremented whenever a ProfilePropertyValue is add/deleted/modified. This Version number is compared with cache copies of the Profile so that consumers can intelligently query and upload the delta updates of the Profile, rather than uploading the entire Profile each time there is a change. <dd>
 *  <dt>firstName</dt><dd>User's first name</dd>
 *  <dt>lastName</dt><dd>User's last name</dd>
 *  <dt>middleInitial</dt><dd>User's middle initial</dd>
 *  <dt>companyName</dt><dd>User's company friendly name</dd>
 *  <dt>jobTitle</dt><dd>User's job title</dd>
 *  <dt>timeZone</dt><dd>User's time zone.  Olson time zone database values are used.</dd>
 *  <dt>phoneNumber</dt><dd>A list of the user's phone numbers.
 *                          HomePhone will expect / return with tags of “Personal” and “Home”
 *                          BusinessWorkPhone will expect / return with tags of “Business” and “Mobile”
 *                          WorkPhone will expect / return with tags of “Business” and “Desk”</dd>
 *  <dt>aliases</dt><dd>List of aliases such as GRCP alias (ex: 88@globalrelay.local) or SIP alias.</dd>
 *  <dt>companyLegalName</dt><dd>User's company legal name. Only used for returning profile information.</dd>
 *  <dt>legalEntityName</dt><dd>User's company legal entity name.</dd>
 *  <dt>legalEntityIdentifier</dt><dd>User's company legal entity identifier (null or 20 chars alpha numeric).</dd>
 *  <dt>companyId</dt><dd>User's company SM Id. Only used for returning profile information.</dd>
 *   <dt>email</dt><dd>Email address of the user.</dd>
 * </dl>
 */
declare class PublicProfileStruct {
  public version: Int64;
  public firstName?: string;
  public lastName?: string;
  public middleInitial?: string;
  public companyName?: string;
  public jobTitle?: string;
  public timeZone?: string;
  public phoneNumbers?: TaggedStringStruct[];
  public aliases?: AliasStruct[];
  public companyLegalName?: string;
  public legalEntityName?: string;
  public legalEntityIdentifier?: string;
  public companyId?: number;
  public userId?: Int64;
  public userSetAttributes?: UserProfileUserSetAttributesStruct;
  public grid?: string;
  public directReports?: ReportsToStruct[];
  public isDirectReportsTruncated?: boolean;
  public companyAddressLine1?: string;
  public companyAddressLine2?: string;
  public companyCity?: string;
  public companyProvince?: string;
  public companyPostalCode?: string;
  public companyCountry?: string;
  public companyPhoneNumber?: string;
  public companyEmail?: string;
  public companyDateModified?: Int64;
  public profileVersion?: Int64;
  public profilePolicyVersion?: Int64;
  public email?: string;

    constructor(args?: { version: Int64; firstName?: string; lastName?: string; middleInitial?: string; companyName?: string; jobTitle?: string; timeZone?: string; phoneNumbers?: TaggedStringStruct[]; aliases?: AliasStruct[]; companyLegalName?: string; legalEntityName?: string; legalEntityIdentifier?: string; companyId?: number; userId?: Int64; userSetAttributes?: UserProfileUserSetAttributesStruct; grid?: string; directReports?: ReportsToStruct[]; isDirectReportsTruncated?: boolean; companyAddressLine1?: string; companyAddressLine2?: string; companyCity?: string; companyProvince?: string; companyPostalCode?: string; companyCountry?: string; companyPhoneNumber?: string; companyEmail?: string; companyDateModified?: Int64; profileVersion?: Int64; profilePolicyVersion?: Int64; email?: string; });
}

/**
 * Return structure from updateRoster RPC
 * 
 */
declare class UpdateRosterReturnStruct {
  public version: Int64;
  public expectNotification: boolean;

    constructor(args?: { version: Int64; expectNotification: boolean; });
}

/**
 * Returned structure from the getAllUsers() API
 * 
 */
declare class UserResultStruct {
  public user?: UserStruct;
  public profile?: PublicProfileStruct;
  public isEntitledForService?: boolean;

    constructor(args?: { user?: UserStruct; profile?: PublicProfileStruct; isEntitledForService?: boolean; });
}

/**
 * <dl>
 *  <dt>users</dt><dd>List with all users and their details.</dd>
 * </dl>
 */
declare class AllUsersResultStruct {
  public users?: UserResultStruct[];

    constructor(args?: { users?: UserResultStruct[]; });
}

/**
 * <dl>
 *  <dt>lastUserId</dt><dd>User Id of last user in last page. New page will contain users after this User Id. Use 0 for first page.</dd>
 *  <dt>pageSize</dt><dd>Page size to return per call.</dd>
 * </dl>
 */
declare class PagingStruct {
  public lastUserId?: Int64;
  public pageSize?: number;

    constructor(args?: { lastUserId?: Int64; pageSize?: number; });
}

/**
 * Profile for a company.
 * 
 */
declare class CompanyProfileStruct {
  public companyId?: number;
  public companyName?: string;
  public addressLine1?: string;
  public addressLine2?: string;
  public city?: string;
  public province?: string;
  public postalCode?: string;
  public country?: string;
  public phoneNumber?: string;
  public website?: string;
  public email?: string;
  public description?: string;
  public productsAndServices?: string;
  public companyLegalName?: string;
  public legalEntityIdentifier?: string;
  public legalEntityName?: string;
  public profileVersion?: Int64;

    constructor(args?: { companyId?: number; companyName?: string; addressLine1?: string; addressLine2?: string; city?: string; province?: string; postalCode?: string; country?: string; phoneNumber?: string; website?: string; email?: string; description?: string; productsAndServices?: string; companyLegalName?: string; legalEntityIdentifier?: string; legalEntityName?: string; profileVersion?: Int64; });
}

/**
 * Logo for a company.
 * 
 */
declare class CompanyLogoStruct {
  public companyLogo?: string;
  public version?: number;
  public logoMimeType?: string;
  public useDefaultLogo?: boolean;

    constructor(args?: { companyLogo?: string; version?: number; logoMimeType?: string; useDefaultLogo?: boolean; });
}

/**
 * Information structure for a single company
 * 
 */
declare class CompanyResultStruct {
  public profile?: CompanyProfileStruct;
  public logo?: CompanyLogoStruct;
  public isEntitledForService?: boolean;

    constructor(args?: { profile?: CompanyProfileStruct; logo?: CompanyLogoStruct; isEntitledForService?: boolean; });
}

/**
 * The structure returned from the getAllCompanies() method
 * 
 */
declare class AllCompaniesResultStruct {
  public companies?: CompanyResultStruct[];

    constructor(args?: { companies?: CompanyResultStruct[]; });
}

/**
 * Paging structure for the getAllCompanies() method
 * 
 */
declare class CompanyPagingStruct {
  public lastCompanyId?: number;
  public pageSize?: number;

    constructor(args?: { lastCompanyId?: number; pageSize?: number; });
}

/**
 * Exception returned when trying to perform an action on a company that does not exist in Service Manager.
 * Such as trying to create users for a non-existing company or trying to delete a company that does not exist.
 */
declare class NoSuchCompanyException extends Thrift.TException {
}

/**
 * Exception returned when trying to create a company that already exists in the Service Manager database.
 */
declare class CompanyAlreadyExistsException extends Thrift.TException {
  public companyId: number;

    constructor(args?: { companyId: number; });
}

/**
 * Exception returned when trying to perform any action using a user id that does not exist in the Service Manager database.
 * This can be returned from several RPC calls including those related to users, avatar, rosters, and profile cards (as they all take in userId as a parameter).
 */
declare class NoSuchUserException extends Thrift.TException {
  public userId: Int64;

    constructor(args?: { userId: Int64; });
}

/**
 * Exception returned if trying to create 0 or less users.
 */
declare class InvalidUserCountException extends Thrift.TException {
}

/**
 * Exception returned if trying to create more users than the max allowed in a single RPC call.
 * (See constant MAX_USERS_PER_CREATE)
 * If more users are desired than the max amount, just call the RPC method several times.
 */
declare class UserCountTooLargeException extends Thrift.TException {
  public maxUsers: number;

    constructor(args?: { maxUsers: number; });
}

/**
 * Exception returned if sending an image that exceed the max allowed size for the image type. (See constants MAX_SOURCEIMAGE_BYTES, MAX_AVATAR_BYTES, MAX_THUMBNAIL_BYTES)
 */
declare class AvatarTooLargeException extends Thrift.TException {
  public maxBytes: number;

    constructor(args?: { maxBytes: number; });
}

/**
 * Exception returned if the base 64 string of source image, avatar, or avatar thumbnail cannot be converted to byte array.
 */
declare class ImageConversionException extends Thrift.TException {
}

/**
 * Generic exception for error not defined in a more specific exception.
 * If a Service Manager validation exception - the entity, property, and validation message will be returned in detailed JSON format inside the description.
 */
declare class FailureException extends Thrift.TException {
  public description: string;

    constructor(args?: { description: string; });
}

/**
 * Exception returned when trying to perform an action on a group that does not exist in Service Manager.
 * Such as trying to add or remove users for a non-existing group.
 */
declare class NoSuchGroupException extends Thrift.TException {
}

/**
 * Exception returned when trying to update a SAML configurations that does not exist in Service Manager.
 * 
 */
declare class NoSuchSamlException extends Thrift.TException {
}

/**
 * Exception returned when trying to create a group name that already exists for the specific company in the Service Manager database.
 */
declare class GroupAlreadyExistsException extends Thrift.TException {
}

/**
 * Exception returned when GRID was not found in Service Manager
 */
declare class GridNotFoundException extends Thrift.TException {
}

/**
 * *
 * The API version included on every request in the X-GR-API-VERSION header
 */
declare var X_GR_API_VERSION_VALUE: string;

declare var MAX_USERS_PER_CREATE: number;

declare var MAX_USERS_PER_GET: number;

declare var MAX_SOURCEIMAGE_BYTES: number;

declare var MAX_AVATAR_BYTES: number;

declare var MAX_THUMBNAIL_BYTES: number;
